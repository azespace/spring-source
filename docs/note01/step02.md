### 运用设计模式实现一个复杂的Bean容器

> 编码方式主要依托于：接口定义，抽象类实现定义的接口，类实现定义的接口，继承抽象类，继承类。从而隔离每个类的基础功能，通用功能，业务功能，当类的职责清晰之后，整个设计也变得更容易扩展。

1. 定义BeanDefinition类，属性并由Object对象改成Class，比较符合类名含义，用于存储各种Bean的元数据
2. 定义单例SingletonBeanRegistry接口用于获取单例Bean
3. 定义DefaultSingletonBeanRegistry，实现单例SingletonBeanRegistry接口的获取单例Bean的方法，并且额外增加一个注册单例Bean的方法addSingleton，该方法用protected修饰，表示给它的子类使用这个方法。该类拥有单例对象的存储容器(Map集合)，存储的是直接就是实例对象Object。也就是说单例Bean容器的注册获取，交给这个类处理了。
4. BeanFactory工厂接口用于获取单例Bean
5. 定义一个抽象工厂类AbstractBeanFactory继承DefaultSingletonBeanRegistry同时实现BeanFactory接口，这个类是一个非常强大的类，他为什么需要继承DefaultSingletonBeanRegistry然后再实现BeanFactory接口的getBean方法呢？是因为它用到了模板方法模式，我们继承DefaultSingletonBeanRegistry就可以获取父类的功能在getBean方法中获取单例，如果拿不到单例，就需要拿到Bean的定义做相应的Bean的实例化操作，Bean的实例化直接在工厂内部完成后放入单例Map并返回，这个类本身并没有实现这些方法，而是定义了过程，由实现了该类的其他类实现，也符合模板方法模式的思想，这一层拥有一些通用方法和实现，但是更详细的实现由不同的子类完成。
6. 定义个自动完成Bean的实例化的抽象类AbstractAutowireCapableBeanFactory ，继承了AbstractBeanFactory类，并且实现了其中一个方法createBean，因为其主要职责是完成Bean的实例化后放入单例Bean容器。
7. 定义BeanDefinitionRegistry接口用于注册BeanDefinition
8. 定义DefaultListableBeanFactory类继承AbstractAutowireCapableBeanFactory抽象类，实现BeanDefinitionRegistry方法，这个类的主要职责就是一个BeanDefinition的Map容器，并且完成BeanDefinition的注册，获取功能。

:gift: 这一小节主要学习不同类与接口之间的职责和关系，所有的程序和功能都离不开接口，抽象类，继承，实现这些功能，而不同特性的类的使用和组合就非常好的隔离开各自的职责和作用范围，配合设计模式更可以隐藏一些实现完成复杂功能，让程序变得易扩展等，这是非常非常重要的知识哦！