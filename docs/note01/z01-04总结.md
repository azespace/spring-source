### Spring总结归纳(以上4章节)

>每一章节都在逐步优化，代码不关键，思路很关键，因为这属于编程思维，设计，它直接影响了代码的质量

1. 一开始我们想的是如何设计Bean容器，方便我们去存储，去随时获取
2. 后来想到了用HashMap存储，并且通过实现Bean定义，注册，获取三步骤确认基本思路
3. 我们要了解的是Spring容器是单例的，客户端发送请求，Control层的每个线程的数据都是单例的，不同线程是维护了不同的BeanFactory实例的，用ThreadLocal技术。单个线程先去单例容器中获取获取不到再去创建对象，返回数据后线程并不会销毁，而是利用了WEB服务器的线程池，每个线程的方法调用结束都会随着方法结束而销毁，所以没有线程安全问题。
4. 先维护一个SingletonBeanRegistry接口定义了单例Map容器获取单例Bean的规范。
5. 再弄个实现类DefaultSingletonBeanRegistry去实现默认获取单例Bean的方法，并且给子类提供了一个注册单例Bean的方法，用protected修饰权限为子类使用 屏蔽具体细节
6. 我们定义了BeanDefinition用于实例化Bean，因为我们要想去实例化对象得获取对象的各个类属性，像Spring是将类全部拆分开了的保存的。
7. 维护了一个BeanFactory接口getBean，用于将BeanDefinition实例化成对象的超级工厂。
8. 然后弄了抽象类AbstractBeanFactory，弄成抽象类主要是为了职责分明，它实现了BeanFactory接口并且继承了DefaultSingletonBeanRegistry，继承就可以拥有单例Map容器的所有控制权了。实现了BeanFactory的getBean，这个getBean有2个重载方法，考虑到Class类的newInstance只能实例化拥有无参构造的类，如果只有有参就会报错。我们使用了反射获取对象需要实例化的属性后实例化，这里有2种方式，一种是JDK的newInstance一种是Cglib的Enhancer类的create方法，第二种比较快基于ASM技术，但是后来JDK9优化了反射的速度(不调用反射API了使用VarHandles方法)，在具体场景下各有优势，无法比较了。
9. getBean方法是先获取的单例的容器的，直接拿对象的有就返回，没有就调用getBeanDefinition方法去BeanDefinition容器获取BeanDefinition类然后通过createBean实例化出来对象再放入单例容器，BeanDefinition容器是一开始Spring初始化就有了的。比较有意思的是getBeanDefinition和createBean是个抽象方法，AbstractBeanFactory这个类并没有实现，而是交给了子类去实现，体现单一职责。
10. 继承了AbstractBeanFactory类的AbstractAutowireCapableBeanFactory实现了其中一个抽象方法createBean，这个方法主要是将传进来的BeanDefinition对象去实例化后放入单例容器。后来设计又出现了问题，实例化后没有给这个对象去填充属性，createBean方法在实例化后又使用了applyPropertyValues方法去填充属性，主要是给BeanDefinition对象增加了个类属性PropertyValues，在一开始实例化的时候准备好PropertyValues，然后实例化后循环PropertyValues类去填充所有的默认属性。
11. 维护了一个抽象类BeanDefinitionRegistry，有个方法registerBeanDefinition主要是用来维护BeanDefinition容器的。
12. 继承了AbstractAutowireCapableBeanFactory类的DefaultListableBeanFactory实现了AbstractBeanFactory抽象父类的另一个抽象方法getBeanDefinition()，并且实现了BeanDefinitionRegistry也就是是说这个DefaultListableBeanFactory抽象类就是BeanDefinition类型的Map容器的维护类。